var splitMix64Next = (function(x1, x2) { // x1: least significant bits, x2: most significant bits
	return function(state1, state2) {
		if (state1 !== null && state1 !== undefined) {
			x1 = state1;
			x2 = state2;
		}
		
		// z = x += 0x9E3779B97F4A7C15
		var z1 = (x1+0x7F4A7C15) >>> 0;
		x2 = (x2 + 0x9E3779B9 + (z1 < x1)) >>> 0;
		x1 = z1;
		var z2 = x2;
		
		// (z ^ (z >> 30))
		z1 ^= (z1 >>> 30) | (z2 << 2);
		z2 ^= z2 >>> 30;
		
		// Multiplication algorithm in JS for 64 bits numbers as 2 32 bit numbers from Google closure library
		// z * 0xBF58476D1CE4E5B9
		var lo2 = 0x1CE4E5B9;
		var hi2 = 0xBF58476D;
		var a32 = z2 & 0xFFFF;
		var a16 = z1 >>> 16;
		var a00 = z1 & 0xFFFF;
		var b32 = hi2 & 0xFFFF;
		var b16 = lo2 >>> 16;
		var b00 = lo2 & 0xFFFF;
		var c00 = a00 * b00;
		var c16 = c00 >>> 16;
		c00 &= 0xFFFF;
		c16 += a16 * b00;
		var c32 = c16 >>> 16;
		c16 &= 0xFFFF;
		c16 += a00 * b16;
		c32 += c16 >>> 16;
		c16 &= 0xFFFF;
		c32 += a32 * b00;
		var c48 = c32 >>> 16;
		c32 &= 0xFFFF;
		c32 += a16 * b16;
		c48 += c32 >>> 16;
		c32 &= 0xFFFF;
		c32 += a00 * b32;
		c48 += c32 >>> 16;
		c32 &= 0xFFFF;
		c48 += (z2 >>> 16) * b00 + a32 * b16 + a16 * b32 + a00 * (hi2 >>> 16);
		c48 &= 0xFFFF;
		z1 = (c16 << 16) | c00;
		z2 = (c48 << 16) | c32;
		
		// (z ^ (z >> 27)
		z1 ^= (z1 >>> 27) | (z2 << 5);
		z2 ^= z2 >>> 27;
		
		// z * 0x94D049BB133111EB
		lo2 = 0x133111EB;
		hi2 = 0x94D049BB;
		a32 = z2 & 0xFFFF;
		a16 = z1 >>> 16;
		a00 = z1 & 0xFFFF;
		b32 = hi2 & 0xFFFF;
		b16 = lo2 >>> 16;
		b00 = lo2 & 0xFFFF;
		c00 = a00 * b00;
		c16 = c00 >>> 16;
		c00 &= 0xFFFF;
		c16 += a16 * b00;
		c32 = c16 >>> 16;
		c16 &= 0xFFFF;
		c16 += a00 * b16;
		c32 += c16 >>> 16;
		c16 &= 0xFFFF;
		c32 += a32 * b00;
		c48 = c32 >>> 16;
		c32 &= 0xFFFF;
		c32 += a16 * b16;
		c48 += c32 >>> 16;
		c32 &= 0xFFFF;
		c32 += a00 * b32;
		c48 += c32 >>> 16;
		c32 &= 0xFFFF;
		c48 += (z2 >>> 16) * b00 + a32 * b16 + a16 * b32 + a00 * (hi2 >>> 16);
		c48 &= 0xFFFF;
		z1 = (c16 << 16) | c00;
		z2 = (c48 << 16) | c32;
		
		// z ^ (z >> 31n)
		return [(z1 ^ ((z1 >>> 31) | (z2 << 1))) >>> 0, (z2 ^ (z2 >>> 31)) >>> 0];
		// The result is returned as two uint32_t integers
	};
})(0, 0);

var IteratorPrototype = typeof Symbol === "undefined" ? null : Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));

function xoShiRoToString() {
	var that = this.peek();
	return that.toString.apply(that, arguments);
}

const UINT64_MAX = 0xffffffffffffffffn;

function rotl$1(x, k) {
  return BigInt.asUintN(64, x << k) | (x >> (64n - k));
}

const next$1 = function (n) {
  return { value: this.nextBigInt(n) };
};

const genericJump$1 = (type, o) => {
  let s0 = 0n;
  let s1 = 0n;
  let s2 = 0n;
  let s3 = 0n;
  const s = o.s;
  for (let i = 0; i < type.length; ++i) {
    for (let b = 0n; b < 64; ++b) {
      if (type[i] & (1n << b)) {
        s0 ^= s[0];
        s1 ^= s[1];
        s2 ^= s[2];
        s3 ^= s[3];
      }
      o.nextBigInt();
    }
  }
  s[0] = s0;
  s[1] = s1;
  s[2] = s2;
  s[3] = s3;
};

const jump$1 = (() => {
  const JUMP = [
    0x180ec6d33cfd0aban,
    0xd5a61266f0c9392cn,
    0xa9582618e03fc9aan,
    0x39abdc4529b1661cn,
  ];
  return function () {
    return genericJump$1(JUMP, this);
  };
})();

const longJump$1 = (() => {
  const JUMP = [
    0x76e15d3efefdcbbfn,
    0xc5004e441c522fb3n,
    0x77710069854ee241n,
    0x39109bb02acbe635n,
  ];
  return function () {
    return genericJump$1(JUMP, this);
  };
})();

const nextFloat = function () {
  const dv = new DataView(new ArrayBuffer(8));
  dv.setBigUint64(0, this.nextBigInt());
  return dv.getFloat64();
};

const nextBigInt = function (n = UINT64_MAX) {
  if (n > UINT64_MAX) {
    throw new RangeError(
      "Illegal bound; must be less than or equal to 0xFFFFFFFFFFFFFFFF (18446744073709551615); bound given: " +
        n
    );
  }

  const s = this.s;
  const t = BigInt.asUintN(64, s[1] << 17n);

  s[2] ^= s[0];
  s[3] ^= s[1];
  s[1] ^= s[2];
  s[0] ^= s[3];

  s[2] ^= t;
  s[3] = rotl$1(s[3], 45n);

  return (s[3] + s[0]) % BigInt(0xffffffffffffffff) & BigInt(0xffffffff);
};

function splitMix64NextBigInt(x1, x2) {
  const [lo, hi] = splitMix64Next(x1, x2);
  return BigInt("0x" + hi.toString(16) + lo.toString(16).padStart(8, "0"));
}

const xoshiro256Maker = (peek) => {
  const XoShiRo256Generator = function (arg1, arg2, arg3, arg4) {
    Object.defineProperty(this, "s", {
      configurable: false,
      value: new BigUint64Array(4),
      writable: false,
    });

    if (arguments.length >= 4) {
      this.s[0] = arg1;
      this.s[1] = arg2;
      this.s[2] = arg3;
      this.s[3] = arg4;
    } else {
      this.s[0] =
        arguments.length === 0
          ? splitMix64NextBigInt()
          : splitMix64NextBigInt(
              Number(arg1 & 0x0000ffffn),
              Number(arg1 & 0xffff0000n)
            );
      this.s[1] = splitMix64NextBigInt();
      this.s[2] = splitMix64NextBigInt();
      this.s[3] = splitMix64NextBigInt();
    }

    if (this.s[0] == 0 && this.s[1] == 0 && this.s[2] == 0 && this.s[3] == 0) {
      console.warn(
        "The state for xoshiro was seeded with all zeroes, so the generator may not function as expected."
      );
    }
  };
  XoShiRo256Generator.prototype = Object.create(IteratorPrototype);
  XoShiRo256Generator.prototype.peek = peek;
  XoShiRo256Generator.prototype.valueOf = peek;

  XoShiRo256Generator.prototype.toString = xoShiRoToString;
  XoShiRo256Generator.prototype.nextBigInt = nextBigInt;
  XoShiRo256Generator.prototype.longJump = longJump$1;
  XoShiRo256Generator.prototype.jump = jump$1;
  XoShiRo256Generator.prototype.next = next$1;
  XoShiRo256Generator.prototype.nextFloat = nextFloat;
  Object.defineProperty(XoShiRo256Generator.prototype, "constructor", {
    value: XoShiRo256Generator,
    enumerable: false,
  });
  return XoShiRo256Generator;
};

const XoShiRo256PlusPlus = xoshiro256Maker(function () {
  const s = this.s;
  return BigInt.asUintN(64, rotl$1(BigInt.asUintN(64, s[0] + s[3]), 23n) + s[0]);
});

const XoShiRo256StarStar = xoshiro256Maker(function () {
  const s = this.s;
  return BigInt.asUintN(64, rotl$1(BigInt.asUintN(64, s[1] * 5n), 7n) * 9n);
});

const XoShiRo256Plus = xoshiro256Maker(function () {
  const s = this.s;
  return BigInt.asUintN(64, s[0] + s[3]);
});

function rotl(x, k) {
	return (x << k) | (x >>> (32 - k));
}
var next = function(n) {
	return { value: this.nextNumber(n) };
};

var genericJump = function(type, o) {
	var s0 = 0;
	var s1 = 0;
	var s2 = 0;
	var s3 = 0;
	var s = o.s;
	for (var i = 0; i < type.length; ++i) {
		for (var b = 0; b < 32; ++b) {
			if (type[i] & (1 << b)) {
				s0 ^= s[0];
				s1 ^= s[1];
				s2 ^= s[2];
				s3 ^= s[3];
			}
			o.nextNumber();
		}
	}
	s[0] = s0;
	s[1] = s1;
	s[2] = s2;
	s[3] = s3;
};

var jump = (function() {
	var JUMP = [0x8764000b, 0xf542d2d3, 0x6fa035c3, 0x77f2db5b];
	return function() {
		return genericJump(JUMP, this);
	}
})();

var longJump = (function() {
	var JUMP = [0xb523952e, 0x0b6f099f, 0xccf5a0ef, 0x1c580662];
	return function() {
		return genericJump(JUMP, this);
	}
})();

var nextNumber = function(n = 0xFFFFFFFF) {
	if (n > 0xFFFFFFFF) {
		throw new RangeError("Illegal bound; must be less than or equal to 0xFFFFFFFF (4294967295); bound given: "+n);
	}
	
	var s = this.s;
	var result;
	do {
		result = this.peek();
		var t = s[1] << 9;
	
		s[2] ^= s[0];
		s[3] ^= s[1];
		s[1] ^= s[2];
		s[0] ^= s[3];
	
		s[2] ^= t;
		s[3] = rotl(s[3], 11);
		
	} while(result >= (0xFFFFFFFF - (0xFFFFFFFF % n)));
	return result % n;
};

function xoshiro128Maker(peek) {
	function XoShiRo128Generator(arg1, arg2, arg3, arg4) {
		var s = [,,,,];
		
		if (arguments.length >= 4) {
			s[0] = arg1;
			s[1] = arg2;
			s[2] = arg3;
			s[3] = arg4;
		} else {
			var r = arguments.length === 0 ? splitMix64Next() : splitMix64Next(arg1, arg2);
			s[0] = r[0];
			s[1] = r[1];
			r = splitMix64Next();
			s[2] = r[0];
			s[3] = r[1];
		}
		
		Object.defineProperty(this, "s", {
			configurable: false,
			value: Object.seal(s),
			writable: false
		});
		
		if (s[0] == 0 && s[1] == 0 && s[2] == 0 && s[3] == 0) {
			console.warn("The state for xoshiro was seeded with all zeroes, so the generator may not function as expected.");
		}
	}	if (IteratorPrototype) {
		XoShiRo128Generator.prototype = Object.create(IteratorPrototype);
	}
	XoShiRo128Generator.prototype.peek = peek;
	XoShiRo128Generator.prototype.valueOf = peek;
	
	XoShiRo128Generator.prototype.toString = xoShiRoToString;
	XoShiRo128Generator.prototype.nextNumber = nextNumber;
	XoShiRo128Generator.prototype.longJump = longJump;
	XoShiRo128Generator.prototype.jump = jump;
	XoShiRo128Generator.prototype.next = next;
	Object.defineProperty(XoShiRo128Generator.prototype, "constructor", {
		value: XoShiRo128Generator,
		enumerable: false
	});
	return XoShiRo128Generator;
}
var XoShiRo128Plus = xoshiro128Maker(function() {
	var s = this.s;
	return (s[0] + s[3]) >>> 0;
});

var XoShiRo128StarStar = xoshiro128Maker(function() {
	var s = this.s;
	return (rotl(s[1] * 5, 7) * 9) >>> 0;
});

var XoShiRo128PlusPlus = xoshiro128Maker(function() {
	var s = this.s;
	return (rotl(s[0] + s[3], 7) + s[0]) >>> 0;
});

export { XoShiRo128Plus, XoShiRo128PlusPlus, XoShiRo128StarStar, XoShiRo256Plus, XoShiRo256PlusPlus, XoShiRo256StarStar };
